(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{489:function(n,u,s){"use strict";s.r(u);var e=s(35),m=Object(e.a)({},(function(){var n=this,u=n.$createElement,s=n._self._c||u;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("p",[n._v("/**")]),n._v(" "),s("ul",[s("li",[n._v("@param {number[]} nums")]),n._v(" "),s("li",[n._v("@param {number} target")]),n._v(" "),s("li",[n._v("@return {number[][]}\n"),s("em",[n._v("/\n/")]),n._v("*")]),n._v(" "),s("li",[n._v("@param {number[]} nums")]),n._v(" "),s("li",[n._v("@return {number[][]}\n*/")])]),n._v(" "),s("p",[n._v("// 两层循环+双指针\nvar fourSum = function(nums, target) {\nlet result = []\nconst len = nums.length\nnums.sort((a, b) => a - b)\nfor (let a = 0; a < len - 3; a++) {\nif (a > 0 && nums[a] === nums[a - 1]) {\ncontinue\n}\nfor (let b = a + 1; b < len; b++) {\n// 左指针\nlet c = b + 1\n// 右指针\nlet d = len - 1\n/* if (nums[i] === nums[i - 1]) {\ncontinue\n} */\nif (b > 0 && nums[b] === nums[b - 1]) {\ncontinue\n}\nwhile (c < d) {\nif (nums[a] + nums[b] + nums[c] + nums[d] < target) {\nc++\nwhile (c < d && nums[c] === nums[c - 1]) {\nc++\n}\n} else if (nums[a] + nums[b] + nums[c] + nums[d] > target) {\nd--\nwhile (c < d && nums[d] === nums[d + 1]) {\nd--\n}\n} else {\nresult.push([nums[a], nums[b], nums[c], nums[d]])\nc++\nd--\nwhile (c < d && nums[c] === nums[c - 1]) {\nc++\n}\nwhile (c < d && nums[d] === nums[d + 1]) {\nd--\n}\n}")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v("\t\t}\n\n\t}\n}\nreturn result\n")])])]),s("p",[n._v("};")]),n._v(" "),s("p",[n._v("/*\n执行结果：\n解答错误\n显示详情\n输入:\n[0,0,0,0]\n0\n输出\n[]\n预期结果\n[[0,0,0,0]]\n"),s("em",[n._v("/\nvar fourSum = function(nums, target) {\nlet result = []\nconst len = nums.length\n// 新增\nif (len < 4) {\nreturn result\n}\n// 并不能达到目的\n/")]),n._v(" if (len = 4) {\nnums[0] + nums[1] + nums[2] + nums[3] == target\n} "),s("em",[n._v("/\nnums.sort((a, b) => a - b)\nfor (let a = 0; a < len - 3; a++) {\nif (a > 0 && nums[a] === nums[a - 1]) {\ncontinue\n}\nfor (let b = a + 1; b < len; b++) {\n// 左指针\nlet c = b + 1\n// 右指针\nlet d = len - 1\n/")]),n._v(" if (nums[i] === nums[i - 1]) {\ncontinue\n} */\nif (b > 0 && nums[b] === nums[b - 1]) {\ncontinue\n}\nwhile (c < d) {\nif (nums[a] + nums[b] + nums[c] + nums[d] < target) {\nc++\nwhile (c < d && nums[c] === nums[c - 1]) {\nc++\n}\n} else if (nums[a] + nums[b] + nums[c] + nums[d] > target) {\nd--\nwhile (c < d && nums[d] === nums[d + 1]) {\nd--\n}\n} else {\nresult.push([nums[a], nums[b], nums[c], nums[d]])\nc++\nd--\nwhile (c < d && nums[c] === nums[c - 1]) {\nc++\n}\nwhile (c < d && nums[d] === nums[d + 1]) {\nd--\n}\n}")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v("\t\t}\n\n\t}\n}\nreturn result\n")])])]),s("p",[n._v("};")]),n._v(" "),s("p",[n._v("// leetcode-others\n/**")]),n._v(" "),s("ul",[s("li",[n._v("@description")]),n._v(" "),s("li",[n._v("排序 + 双指针")]),n._v(" "),s("li",[n._v("@param {number[]} nums")]),n._v(" "),s("li",[n._v("@param {number} target")]),n._v(" "),s("li",[n._v("@return {number[][]}\n*/\nvar fourSum = function(nums, target) {\nlet nums = nums.sort((a, b) => a - b);\nlet len = nums.length;\nif (len < 4) return [];\nlet result = [];\nfor (let i = 0; i < len - 3; i++) {\n// 如果当前循环值与前一个值相同，则判断存在重复，跳过此次循环\nif (i > 0 && nums[i] === nums[i - 1]) continue;\nif (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) break;\nif (nums[i] + nums[len - 1] + nums[len - 2] + nums[len - 3] < target) continue;\nfor (let b = i + 1; b < len - 2; b++) {\nlet c = b + 1;\nlet d = len - 1;\n// 如果当前循环值与前一个值相同，则判断存在重复，跳过此次循环\n// 注意这里的判断条件\n// 因为当前b = i + 1\n// 这里判断的是后一个数字是否和现在的数字相等\n// 所以后一个数字的b至少为 b+1 = i+2\n// 所以此处的判断条件为b - 1 > i\nif (b - 1 > i && nums[b] === nums[b - 1]) continue;\nwhile (c < d) {\nif (nums[i] + nums[b] + nums[c] + nums[d] === target) {\nresult.push([nums[i], nums[b], nums[c], nums[d]]);\nwhile (c < d && nums[c] === nums[c + 1]) {\nc++;\n}\nwhile (c < d && nums[d] === nums[d - 1]) {\nd--;\n}\n// 执行到这里，左右指针都指向了最后一个与c值相同的位置，\n// 此时我们还需要将左右指针再次向前进位，跳过最后一个重复值\n// [1,1,1,1,2,3,4,5,6]\n// 此时c指针在最后一个1处，还是与最开头的1重复，所以再次\n// 加1,指针指向不重复的值\nc++;\nd--;\n} else {\nnums[i] + nums[b] + nums[c] + nums[d] > target ?\nd--\n:\nc++\n}\n}\n}\n}\nreturn result;\n}")])]),n._v(" "),s("p",[n._v("/* 作者： bin - bi - de - xiao - chao - ren\n链接： https: //leetcode-cn.com/problems/4sum/solution/si-shu-zhi-he-by-bin-bi-de-xiao-chao-ren/\n来源： 力扣（ LeetCode）\n著作权归作者所有。 商业转载请联系作者获得授权， 非商业转载请注明出处。 */")]),n._v(" "),s("p",[n._v("// 替换字母\nvar fourSum = function(nums, target) {\nlet result = []\nconst len = nums.length\n// 新增\nif (len < 4) {\nreturn result\n}\nnums.sort((a, b) => a - b)\nfor (let a = 0; a < len - 3; a++) {\n// 如果当前循环值与前一个值相同，则判断存在重复，跳过此次循环\nif (a > 0 && nums[a] === nums[a - 1]) continue;\nif (nums[a] + nums[a + 1] + nums[a + 2] + nums[a + 3] > target) break;\nif (nums[a] + nums[len - 1] + nums[len - 2] + nums[len - 3] < target) continue;\nfor (let b = a + 1; b < len - 2; b++) {\nlet c = b + 1;\nlet d = len - 1;\n// 如果当前循环值与前一个值相同，则判断存在重复，跳过此次循环\n// 注意这里的判断条件\n// 因为当前b = a + 1\n// 这里判断的是后一个数字是否和现在的数字相等\n// 所以后一个数字的b至少为 b+1 = a+2\n// 所以此处的判断条件为b - 1 > a\nif (b - 1 > a && nums[b] === nums[b - 1]) continue;\nwhile (c < d) {\nif (nums[a] + nums[b] + nums[c] + nums[d] === target) {\nresult.push([nums[i], nums[b], nums[c], nums[d]]);\nwhile (c < d && nums[c] === nums[c + 1]) {\nc++;\n}\nwhile (c < d && nums[d] === nums[d - 1]) {\nd--;\n}\n// 执行到这里，左右指针都指向了最后一个与c值相同的位置，\n// 此时我们还需要将左右指针再次向前进位，跳过最后一个重复值\n// [1,1,1,1,2,3,4,5,6]\n// 此时c指针在最后一个1处，还是与最开头的1重复，所以再次\n// 加1,指针指向不重复的值\nc++;\nd--;\n} else {\nnums[a] + nums[b] + nums[c] + nums[d] > target ?\nd--\n:\nc++\n}\n}\n}\n}\nreturn result;\n}")]),n._v(" "),s("h2",{attrs:{id:"更改自己的代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#更改自己的代码"}},[n._v("#")]),n._v(" 更改自己的代码")]),n._v(" "),s("p",[n._v("/**")]),n._v(" "),s("ul",[s("li",[s("p",[n._v("@param {number[]} nums")])]),n._v(" "),s("li",[s("p",[n._v("@return {number[][]}\n*/\nvar fourSum = function(nums, target) {\nlet result = []\nconst len = nums.length\n// 新增\nif (len < 4) {\nreturn result\n}\nnums.sort((a, b) => a - b)\nfor (let a = 0; a < len - 3; a++) {\n// 如果当前循环值与前一个值相同，则判断存在重复，跳过此次循环\nif (a > 0 && nums[a] === nums[a - 1]) continue;\nif (nums[a] + nums[a + 1] + nums[a + 2] + nums[a + 3] > target) break;\nif (nums[a] + nums[len - 1] + nums[len - 2] + nums[len - 3] < target) continue;\nfor (let b = a + 1; b < len; b++) {\n// 左指针\nlet c = b + 1\n// 右指针\nlet d = len - 1\n// 如果当前循环值与前一个值相同，则判断存在重复，跳过此次循环\n// 注意这里的判断条件\n// 因为当前b = a + 1\n// 这里判断的是后一个数字是否和现在的数字相等\n// 所以后一个数字的b至少为 b+1 = a+2\n// 所以此处的判断条件为b - 1 > a\nif (b > a + 1 && nums[b] === nums[b - 1]) continue;\nwhile (c < d) {\nif (nums[a] + nums[b] + nums[c] + nums[d] < target) {\nc++\nwhile (c < d && nums[c] === nums[c - 1]) {\nc++\n}\n} else if (nums[a] + nums[b] + nums[c] + nums[d] > target) {\nd--\nwhile (c < d && nums[d] === nums[d + 1]) {\nd--\n}\n} else {\nresult.push([nums[a], nums[b], nums[c], nums[d]])\nc++\nd--\nwhile (c < d && nums[c] === nums[c - 1]) {\nc++\n}\nwhile (c < d && nums[d] === nums[d + 1]) {\nd--\n}\n}")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v(" \t}\n\n }\n")])])]),s("p",[n._v("}\nreturn result\n};\n// 测试\nlet nums = [-2, 0, 0, 0, 0, 2]\nconsole.log(fourSum(nums, 0))")])])]),n._v(" "),s("p",[n._v("/*\n注意这个判断条件\nif (b > a + 1 && nums[b] === nums[b - 1]) continue;\n输出[[-2, 0, 0, 2],[0, 0, 0, 0]]\nif (b > 0 && nums[b] === nums[b - 1]) continue;\n只输出[-2, 0, 0, 2]\n*/")])])}),[],!1,null,null,null);u.default=m.exports}}]);